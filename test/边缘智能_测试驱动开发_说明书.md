# Bash 脚本测试驱动开发（TDD）说明书

版本：v1.0  
适用范围：Shell / DevOps / Kubernetes 运维脚本  
目标：保证逻辑完整、行为可验证、可回归、可持续演进  

---

# 一、测试驱动核心理念

测试驱动开发（TDD）流程：

1️⃣ 先写“测试观点说明书”  
2️⃣ 再写实现代码  
3️⃣ 再写测试代码  
4️⃣ 再写测试使用说明书  

原则：

- 观点先于代码
- 设计先于实现
- 行为必须可验证
- 逻辑必须可回归

---

# 二、第一步：设立测试观点说明书

## 目的

在写代码前，先明确：

- 系统要验证什么？
- 每个函数的行为是什么？
- 出现异常时返回什么？
- 汇总逻辑如何决策？

---

## 示例结构（观点表）

| 编号 | 函数 | 场景 | 期望 |
|------|------|------|------|
| UT-01 | check_namespace | namespace 不存在 | error |
| UT-02 | check_namespace | enforce 模式 | warning |
| UT-03 | check_service | service 不存在 | error |
| UT-04 | check_pvc | pvc 命名不规范 | warning |
| UT-05 | check_pod | pod 非 Running | error |
| UT-06 | calculate_summary | 有 error | error |
| UT-07 | calculate_summary | 仅 warning | warning |
| UT-08 | calculate_summary | 无异常 | ok |

---

## 设计原则

- 每个函数必须至少 1 个测试观点
- 汇总逻辑必须覆盖所有分支
- 正常路径 + 异常路径必须完整
- 不允许“隐式行为”

---

# 三、第二步：生成代码

规则：

- 代码必须完全围绕观点表实现
- 每个观点必须能找到对应函数逻辑
- 逻辑必须可被 mock
- 外部依赖必须抽象（如 kubectl → kctl）

示例：

```bash
kctl() {
  kubectl "$@"
}
```

这样测试时可以覆盖。

---

# 四、第三步：生成测试代码

目标：

- 不依赖真实环境
- 不执行主流程
- 只测试函数逻辑
- 使用 mock 替代外部命令

结构：

```bash
source ./target_script.sh

# 覆盖依赖
kctl() {
  mock_kctl "$@"
}

# 写断言
assert_equal "error" "$result"
```

---

## 测试原则

- 一个观点 = 一个 assert
- 测试必须可重复执行
- 不允许状态污染（每次重置 json_entries）
- 测试失败必须 exit 1

---

# 五、第四步：生成测试使用说明书

内容必须包含：

1. 如何执行测试
2. 执行了哪些函数
3. 返回结果格式
4. 失败时如何排查
5. 如何新增测试

---

## 示例执行说明

```bash
chmod +x gitlab_ha_full_deploy_UnitTest.sh
./gitlab_ha_full_deploy_UnitTest.sh
```

成功输出：

```
✅ PASS
✅ PASS
...
🎉 All tests passed
```

---

# 六、完整 TDD 生命周期

1️⃣ 写观点  
2️⃣ 写代码  
3️⃣ 写测试  
4️⃣ 执行测试  
5️⃣ 修复失败  
6️⃣ 全部 PASS  
7️⃣ 提交代码  

---

# 七、判断代码是否健全的标准

✔ 所有观点均有对应测试  
✔ 所有测试均 PASS  
✔ 外部依赖可 mock  
✔ 汇总逻辑无死角  
✔ 新增需求只需新增观点 + 测试  

---

# 八、企业级 TDD 评价标准

| 级别 | 标准 |
|------|------|
| 初级 | 有测试 |
| 中级 | 覆盖异常路径 |
| 高级 | mock 隔离完整 |
| 企业级 | 观点驱动 + CI 自动执行 |

---

# 九、总结

测试驱动开发本质是：

> 观点驱动代码，而不是代码驱动测试。

正确顺序：

观点 → 代码 → 测试 → 说明书

只要遵循这个流程：

代码一定健全  
逻辑一定可验证  
系统一定可持续演进  

---

文档结束
